import pandas as pd
import numpy as np
import os
import tkinter
import re
import concurrent.futures

from tkinter import filedialog, messagebox
from itertools import chain

from .utils import sorted_alphanumeric, printProgressBar, inDict

def select_data_file(file_extension = ".txt"):
    """
    Function that brings a pop up prompt to select the mach-1 file or MAP file

    Args:
        files (list): Files from directory to sort.

    Returns:
        files sorted: files sorted.
    """ 
    pop_window = tkinter.Tk()
    pop_window.withdraw()
    pop_window.attributes('-topmost', True) 
    filename = filedialog.askopenfilename(parent=pop_window, initialdir= "/", title='Please select the Mach-1 .txt file or MAP file')
    if len(filename) == 0 or not filename.endswith(file_extension):
        messagebox.showwarning("Warning", "No mach-1 or MAP file selected!")
        filename = None
    return filename

def select_data_file_dir(keyword = None, read_MAP = False):
    """
    Function that brings a pop up prompt to select a folder contaning multiple mach-1 files or MAP files.

    Args:
        keyword (str): String Name of group of mach-1 files to load in folder.
        read_MAP (Bool): Bool to indicate whether to select mach_1 files or MAP files.

    Returns:
        files (list): files of the mach-1 from the folder or MAP files.
    """
    file_extension = ".txt"
    mach_1_files = []
    mach_1_dir = []
    mach_1_fnames = []
    pop_window = tkinter.Tk()
    pop_window.withdraw()
    pop_window.attributes('-topmost', True) 
    main_dir = filedialog.askdirectory(parent=pop_window, initialdir= "/", title='Please select the Mach-1 files directory')
    if read_MAP:
        file_extension = ".map"
    try:
        print("Mach-1 files located at : " + main_dir)
        mach_1_files = sorted(filter(lambda x: os.path.isfile(os.path.join(main_dir, x)), os.listdir(main_dir)))
        if keyword is None:
            mach_1_dir = [os.path.join(main_dir, file) for file in mach_1_files if file.endswith(file_extension)]
        else:
            mach_1_dir = [os.path.join(main_dir, file) for file in mach_1_files if file.endswith(file_extension) and keyword in file.split(".")[0]]
        mach_1_dir = sorted_alphanumeric(mach_1_dir)
        mach_1_fnames = [file.split("\\")[-1].split(".")[0] for file in mach_1_dir] 
    except:
        print("No directory selected or directory does not exist...")
    mach_1_sets =  [[mach_1_dir[i], mach_1_fnames[i]] for i in range(len(mach_1_fnames))]
    return mach_1_sets

def prepareData(dataframe, dataHeaders):
    """
    Function that converts data array to dictionary.

    Args:
        dataframe (pd.dataframe): Panda dataframe
        dataHeaders (list): Data headers of the dataframe

    Returns:
        df_Data (dict): Dictionary with the headers of the dataframe.
    """
    df_Data = {}
    for idx, dataHeader in enumerate(dataHeaders):
        df_Data[dataHeader.split(",")[0]] = dataframe.values[:,idx]
    return df_Data

def selectData(filename, idxs_dividers, idx_function, data_headers_selection):
    """
    Function that selects specific data headers of Mach-1 file.

    Args:
        filename (str): filename of Mach-1 file
        idxs_dividers (list): Indexes of Mach-1 file dividers
        idx_function (int): Index of function row in Mach-1 file
        data_headers_selection (list): selected data headers

    Returns:
        data_indexes (dict): Data indexes of the selected data headers.
    """
    data_indexes = None
    if data_headers_selection is not None:
        all_data_headers = pd.read_csv(filename, sep="\t", skiprows = idxs_dividers[4*idx_function+2], nrows=0, engine="c", na_filter=False, low_memory=False).columns.values
        all_data_headers = [dataHeader.split(",")[0] for dataHeader in all_data_headers]
        data_indexes = [all_data_headers.index(selection) for selection in data_headers_selection]
    return data_indexes

def search_dividers(mach_1_file, divider):
    """
    Searches the mach-1 file for a specific divider

    Args:
        mach_1_file (str): .txt file name generated by Mach-1 Motion 
        divider (str): String containing the name of divider

    Returns:
        indexes (list): List of row position of the given divider in the .txt file.
    """
    with open(mach_1_file) as file:
        indexes = [] # data structure to store divider row position in .txt file
        for idx, line in enumerate(file, 1):
            if divider in line:
                indexes.append(idx)
    return indexes

def search_dividers_idx(mach_1_file, dividers):
    """
    Extracts the row position of all dividers in text mach-1 file

    Args:
        mach_1_file (str): .txt file name generated by Mach-1 Motion 
        dividers (list): List of strings containing all dividers used in mach-1 .txt file

    Returns:
        indexes_file (list): List of row positions in order of the given dividers found in the .txt file
    """
    indexes_file = []
    for divider in dividers:
        indexes_file.append(search_dividers(mach_1_file, divider))
    indexes_file = list(chain.from_iterable(indexes_file))
    indexes_file = sorted(indexes_file)
    return indexes_file

def check_data_separator(mach_1_file, idxs_dividers):
    """
    Verifies that a function in the mach-1 file has a data separator 

    Args:
        mach_1_file (str): .txt file name generated by Mach-1 Motion 
        idxs_dividers (list): Indexes of Mach-1 file dividers

    Returns:
        flag_data_separators (list): List Booleans that checks if "<divider>" is in a function of the mach-1 file
        idx (int): Position of the row of "<divider>" if is in a function of the mach-1 file
    """
    indexes = []
    flag_dividers = []
    with open(mach_1_file) as file:
        flag_divider = False
        for idx, line in enumerate(file, 1):
            if "<divider>" in line:
                indexes.append(idx)
    for ix in range(len(idxs_dividers)//4):
        if len(indexes) > 0:
            for idy in indexes:
                if idy > idxs_dividers[4*ix+2] and idy < idxs_dividers[4*ix+3]:
                    flag_divider = True
                    break
            flag_dividers.append(flag_divider)
            flag_divider = False
        else:
            flag_dividers.append(False)
    return flag_dividers, indexes

def read_mach_1_file(mach_1_file, read_data = 1, data_headers_selection = None, showProgressBar = True):
    """
    Loads all data of mach-1 file into a structure separated by the file 

    Args:
        mach_1_file (str): .txt file name generated by Mach-1 Motion 
        read_data (int): Integer indicating if the numerical data in the Mach-1 .txt file should be read. Default value is 1. 0: Read only the info.
        data_headers_selection (list): List of specific data headers to load
        showProgressBar (Bool): Flag to show progress bar on command prompt

    Returns:
        dfMACH_1 (dict): Structure containing everything read from the Mach-1 Motion .txt file.
    """
    dfMACH_1 = {} # dictionary to store all mach-1 data
    # Dividers used to separate steps in .txt file
    dividers = ["<INFO>","<END INFO>","<DATA>","<END DATA>"]
    # Verify the file is valid and Mach-1 file
    if not mach_1_file or not os.path.exists(mach_1_file) and not mach_1_file.endswith(".txt"):
        raise ValueError("Incorrect file extension or file does not exist.")
    idxs_dividers = search_dividers_idx(mach_1_file, dividers) # row position of dividers in .txt file
    flag_data_separators, idxs_data_separators = check_data_separator(mach_1_file, idxs_dividers)
    # Start to load data from Mach-1 file into dictionary
    dicFuncNames = {}
    for function in range(len(idxs_dividers)//4):
        dfINFO = pd.read_csv(mach_1_file, sep="\t", skiprows = idxs_dividers[4*function]-1, nrows=idxs_dividers[4*function+1]-idxs_dividers[4*function]-2, engine="c", na_filter=False, low_memory=False).to_dict() # extract mach-1 experiment info
        dfFUNCTION = pd.read_csv(mach_1_file, sep="\t", skiprows = idxs_dividers[4*function+1], nrows=idxs_dividers[4*function+2]-idxs_dividers[4*function+1]-2, engine="c", na_filter=False, low_memory=False).to_dict() # extract function info
        funcName = list(dfFUNCTION.keys())[0].split("<")[-1].split(">")[0] 
        if funcName in dicFuncNames:
            dicFuncNames[funcName] += 1
        else:
            dicFuncNames[funcName] = 1
        currentFunc = funcName + "-{}".format(dicFuncNames[funcName])
        if read_data == 1:
            dfDATA = {}
            count = 0
            if flag_data_separators[function] == False:
                data_indexes = selectData(mach_1_file, idxs_dividers, function, data_headers_selection)
                df = pd.read_csv(mach_1_file, sep="\t", skiprows = idxs_dividers[4*function+2], nrows=idxs_dividers[4*function+3]-idxs_dividers[4*function+2]-2, usecols=data_indexes, engine="c", na_filter=False, low_memory=False)
                dataHeaders = df.columns.values
                dfDATA = {"<DATA>" : prepareData(df, dataHeaders)}
            if flag_data_separators[function] == True:
                for separator in range(len(idxs_data_separators)):
                    if idxs_data_separators[separator] > idxs_dividers[4*function+2] and idxs_data_separators[separator] < idxs_dividers[4*function+3]:
                        if len(idxs_data_separators) == 1:
                            data_indexes = selectData(mach_1_file, idxs_dividers, function, data_headers_selection)
                            df = pd.read_csv(mach_1_file, sep="\t", skiprows = idxs_dividers[4*function+2], nrows=idxs_data_separators[separator]-idxs_dividers[4*function+2]-2, usecols=data_indexes, engine="c", na_filter=False, low_memory=False)
                            dataHeaders = df.columns.values
                            data = {"<DATA>"  : {'Ramp-{}'.format(separator + 1): prepareData(df, dataHeaders)}}
                            dfDATA.update(data)
                            break
                        if idxs_data_separators[separator - 1] > idxs_dividers[4*function + 2]: 
                            if idxs_data_separators[separator -1] > idxs_dividers[4*function +3] or idxs_data_separators[separator - 1] + 1 == idxs_dividers[4*function + 3]:
                                data_indexes = selectData(mach_1_file, idxs_dividers, function, data_headers_selection)
                                df = pd.read_csv(mach_1_file, sep="\t", skiprows = idxs_dividers[4*function+2], nrows=idxs_data_separators[separator]-idxs_dividers[4*function+2]-2, usecols=data_indexes, engine="c", na_filter=False, low_memory=False)
                                dataHeaders = df.columns.values
                                data = {'<DATA>' : {'Ramp-{}'.format(separator + 1): prepareData(df, dataHeaders)}}
                                dfDATA.update(data)
                                count += 1
                                if idxs_data_separators[separator + 1] > idxs_dividers[4*function+3]:
                                    break
                            elif idxs_data_separators[separator] > idxs_data_separators[separator - 1]:
                                df = pd.read_csv(mach_1_file, sep="\t", header = None, skiprows = idxs_data_separators[separator-1], nrows=idxs_data_separators[separator]-idxs_data_separators[separator-1]-1, usecols=data_indexes, engine="c", na_filter=False, low_memory=False)
                                data = {'Ramp-{}'.format(separator + 1):prepareData(df, dataHeaders)}
                                dfDATA['<DATA>'].update(data)
                                count += 1
            for id in range(count):
                del idxs_data_separators[0]
            dfINFO.update(dfFUNCTION)
            dfINFO.update(dfDATA)
            dM = {currentFunc : dfINFO}
            dfMACH_1.update(dM) 
        else:
            dfINFO.update(dfFUNCTION)
            dM = {funcName : dfINFO}
            dfMACH_1.update(dM)
        if  showProgressBar:
            printProgressBar(function, len(idxs_dividers)//4 - 1, prefix='Progress:', suffix='Complete', length=50)
    return dfMACH_1

def load_routine(mach_1_set):
    """
    Load routine for multiprocessing

    Args:
        mach_1_set (list): input parameters for read_mach_1_file function 

    Returns:
        dfMach_1 (dict): Structure containing everything read from the folder of Mach-1 Motion .txt files.
    """
    mach_1_dir, mach_1_fname, read_data, data_headers_selection, showProgressBar = mach_1_set
    print(f"Loading - {mach_1_fname}...")
    dfMach_1 = {mach_1_fname : read_mach_1_file(mach_1_dir, read_data=read_data, data_headers_selection= data_headers_selection, showProgressBar=showProgressBar)}
    return dfMach_1 

def read_mach_1_files(read_data = 1, data_headers_selection = None, keyword=None, showProgressBar = True, multiprocessing = False):
    """
    Reads multiple mach-1 files in a folder

    Args:
        read_data (int): Integer indicating if the numerical data in the Mach-1 .txt file should be read. Default value is 1. 0: Read only the info.
        data_headers_selection (list): List of specific data headers to load
        showProgressBar (Bool): Flag to show progress bar on command prompt
        multiprocessing (Bool): Flag to indicate whether to use multiprocessing to load mach-1 files

    Returns:
        dfMach_1 (dict): Structure containing everything read from the folder of Mach-1 Motion .txt files.
    """
    dfMACH_1s = {}
    mach_1_dir = None
    mach_1_sets = select_data_file_dir(keyword)
    if len(mach_1_sets) > 0:
        if multiprocessing:
            for mach_1_set in mach_1_sets:
                mach_1_set.append(read_data)
                mach_1_set.append(data_headers_selection)
                mach_1_set.append(showProgressBar) 
            with concurrent.futures.ProcessPoolExecutor() as executor:
                results = executor.map(load_routine, mach_1_sets)
            dfMACH_1s =  {}
            for result in results:
                dfMACH_1s.update(result)
            mach_1_dir = os.path.dirname(mach_1_sets[0][0])
        else:
            for index in range(len(mach_1_sets)):
                print("Loading: " + mach_1_sets[index][1])
                if data_headers_selection is not None:
                    dfMACH_1s[mach_1_sets[index][1]] = read_mach_1_file(mach_1_sets[index][0], read_data, data_headers_selection)
                else:
                    dfMACH_1s[mach_1_sets[index][1]] = read_mach_1_file(mach_1_sets[index][0], read_data)
            mach_1_dir = os.path.dirname(mach_1_sets[0][0])
    else:
        messagebox.showwarning("Warning", "No mach-1 files found!")
    return dfMACH_1s, mach_1_dir

def get_subSurfaces(MAP_file, keyword = ""):
    """
    Function to separate surfaces from MAP in dictionary

    Args:
        MAP_file:  Name of the MAP to load
        keyword:  Name given to the measurements in the MAP file
    
    Returns
        subSurfaces :  Dictionary of all the surfaces identified in the MAP file                         
    """
    subSurfaces = {}
    df_MAP = pd.read_csv(MAP_file , sep="\t",  skiprows = 6, engine="c", na_filter=False, low_memory=False).to_dict()
    df_MAP_info = pd.read_csv(MAP_file , sep="\t",  nrows = 5, usecols = [1], engine="c", na_filter=False, low_memory=False).values
    subSurfaces["MAP-Info"] = {"Software version" : df_MAP_info[0, 0], "Image" : df_MAP_info[3, 0], "Image directory" : os.path.join(os.path.dirname(MAP_file), df_MAP_info[3,0])}
    keyword_flag = inDict(df_MAP, keyword)
    for id in range(len(df_MAP["PointType"])):
        pt_type = df_MAP["PointType"][id]
        if pt_type == 0 or pt_type == 2:
            subSurf_ID = df_MAP["Sub-SurfaceID"][id]
            if pt_type == 2:
                subSurf_ID = "references"
            pt = np.array([df_MAP["PixelX"][id], df_MAP["PixelY"][id]])
            pt_ID = df_MAP["PointID"][id]
            flag = inDict(subSurfaces, subSurf_ID)
            if flag:
                subSurfaces[subSurf_ID]["Position"].append(pt)
                subSurfaces[subSurf_ID]["Position ID"].append(pt_ID)
                if keyword_flag:
                    subSurfaces[subSurf_ID][keyword].append(float(df_MAP[keyword][id]))
            else:
                if keyword_flag:
                    subSurfaces[subSurf_ID] = {"Position": [pt], "Position ID": [pt_ID], keyword: [float(df_MAP[keyword][id])]}
                else:
                    subSurfaces[subSurf_ID] = {"Position": [pt], "Position ID": [pt_ID]}           
        elif pt_type == 1:
            subSurf_ID = df_MAP["Sub-SurfaceID"][id]
            Pixel = np.array([df_MAP["PixelX"][id], df_MAP["PixelY"][id]])
            flag = inDict(subSurfaces, subSurf_ID)
            if flag:
                bounds_flag = inDict(subSurfaces[subSurf_ID], "Bounds")
                if bounds_flag:
                    subSurfaces[subSurf_ID]["Bounds"].append(Pixel)
                else:
                    subSurfaces[subSurf_ID]["Bounds"] = [Pixel]
            else:
                subSurfaces[subSurf_ID] = {"Bounds": [Pixel]}                      
    return subSurfaces

